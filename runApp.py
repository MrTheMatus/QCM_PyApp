# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'form_backup_9.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import os
from PyQt5 import QtCore, QtGui, QtWidgets
from pyqtgraph import GraphicsLayoutWidget, PlotWidget
import argparse
import platform
import sys
import logging
import logging.handlers
from enum import Enum
import multiprocessing
from time import sleep
from multiprocessing import Queue
from time import time
import serial
from serial.tools import list_ports
import socket
import numpy as np
import csv
import multiprocessing
from time import strftime, gmtime, sleep
from pyqtgraph import AxisItem
import platform
import string
from csv import writer
from datetime import datetime
from os.path import exists as file_exists
from pympler.classtracker import ClassTracker

TAG = "AffordableQCM"
tare =4000000
density = 0.05
pathname2 = ''
pathname =''
tracker = ClassTracker()
class Architecture:
    """
    Wrappers for architecture specific methods.
    """

    @staticmethod
    def get_os():
        """
        Gets the current OS type of the host.
        :return: OS type by OSType enum.
        """
        tmp = str(Architecture.get_os_name())
        if "Linux" in tmp:
            return OSType.linux
        elif "Windows" in tmp:
            return OSType.windows
        elif "Darwin" in tmp:
            return OSType.macosx
        else:
            return OSType.unknown

    @staticmethod
    def get_os_name():
        """
        Gets the current OS name string of the host (as reported by platform).
        :return: OS name.
        :rtype: str.
        """
        return platform.platform()

    @staticmethod
    def get_path():
        """
        Gets the PWD or CWD of the currently running application.
        :return: Path of the PWD or CWD.
        :rtype: str.
        """
        return sys.path[0]

    @staticmethod
    def get_python_version():
        """
        Gets the running Python version (Major, minor, release).
        :return: Python version formatted as major.minor.release.
        :rtype: str.
        """
        version = sys.version_info
        return str("{}.{}.{}".format(version[0], version[1], version[2]))

    @staticmethod
    def is_python_version(major, minor=0):
        """
        Checks if the running Python version is equal or greater than the specified version.
        :param major: Major value of the version.
        :type major: int.
        :param minor: Minor value of the version.
        :type minor: int.
        :return: True if the version specified is equal or greater than the current version.
        :rtype: bool.
        """
        version = sys.version_info
        if version[0] >= major and version[1] >= minor:
            return True
        return False


class OSType(Enum):
    """
    Enum to list OS types.
    """
    unknown = 0
    linux = 1
    macosx = 2
    windows = 3





TAG2 = "Arguments"


class Arguments:
    """
    Wrapper for argparse package.
    """
    def __init__(self):
        self._parser = None

    def create(self):
        """
        Creates and parses the arguments to be used by the application.
        :return:
        """
        parser = argparse.ArgumentParser(description='RTGraph\nA real time plotting and logging application')
        parser.add_argument("-i", "--info",
                            dest="log_level_info",
                            action='store_true',
                            help="Enable info messages"
                            )

        parser.add_argument("-d", "--debug",
                            dest="log_level_debug",
                            action='store_true',
                            help="Enable debug messages"
                            )

        parser.add_argument("-v", "--verbose",
                            dest="log_to_console",
                            action='store_true',
                            help="Show log messages in console",
                            default=Constants.log_default_console_log
                            )

        parser.add_argument("-s", "--samples",
                            dest="user_samples",
                            default=Constants.argument_default_samples,
                            help="Specify number of sample to show on plot"
                            )
        self._parser = parser.parse_args()

    def set_user_log_level(self):
        """
        Sets the user specified log level.
        :return:
        """
        if self._parser is not None:
            self._parse_log_level()
        else:
            Logger.w(TAG2, "Parser was not created !")
            return None

    def get_user_samples(self):
        """
        Gets the user specified samples to show in the plot.
        :return: Samples specified by user, or default value if not specified.
        :rtype: int.
        """
        return int(self._parser.user_samples)

    def get_user_console_log(self):
        """
        Gets the user specified log to console flag.
        :return: True if log to console is enabled.
        :rtype: bool.
        """
        return self._parser.log_to_console

    def _parse_log_level(self):
        """
        Sets the log level depending on user specification.
        It will also enable or disable log to console based on user specification.
        :return:
        """
        log_to_console = self.get_user_console_log()
        level = LoggerLevel.INFO
        if self._parser.log_level_info:
            level = LoggerLevel.INFO
        elif self._parser.log_level_debug:
            level = LoggerLevel.DEBUG
        Logger(level, enable_console=log_to_console)

class SourceType(Enum):
    """
    Enum for the types of sources. Indices MUST match app_sources constant.
    """
    simulator = 1
    serial = 0
    SocketClient = 2


class Constants:
    """
    Common constants for the application.
    """
    app_title = "RTGraph-openQCM"
    app_version = '0.1'
    app_export_path = "data"
    app_sources = ["Serial", "Simulator", "Socket Client"]
    app_encoding = "utf-8"

    '''
    TODO 
    custom change: slowing down the update of the timer 
    the QCM data rate is 1 sample/sec 
    '''
    # plot_update_ms = 16
    plot_update_ms = 100
    plot_xlabel_title = "Time"
    plot_xlabel_unit = "s"
    plot_colors = ['#0072bd', '#d95319', '#edb120', '#7e2f8e', '#77ac30', '#4dbeee', '#a2142f']
    plot_max_lines = len(plot_colors)

    process_join_timeout_ms = 1000

    argument_default_samples = 500

    serial_default_speed = 115200
    serial_timeout_ms = 0.5

    class SocketClient:
        timeout = 0.01
        host_default = "localhost"
        port_default = [5555, 8080, 9090]
        buffer_recv_size = 1024

    simulator_default_speed = 0.002

    csv_default_filename = "%Y-%m-%d_%H-%M-%S"
    csv_delimiter = ","
    csv_extension = "csv"

    parser_timeout_ms = 0.005

    log_filename = "{}.log".format(app_title)
    log_max_bytes = 5120
    log_default_level = 1
    log_default_console_log = False


class MinimalPython:
    """
    Specifies the minimal Python version required.
    """
    major = 3
    minor = 2
    release = 0

##########################################
#  Provides a non scientific axis notation
##########################################  
# TODO
class NonScientificAxis(AxisItem):
    def __init__(self, *args, **kwargs):
        super(NonScientificAxis, self).__init__(*args, **kwargs)

    def tickStrings(self, values, scale, spacing):
        return [int(value*1) for value in values] 





TAG3 = "CSV"


class CSVProcess(multiprocessing.Process):
    """
    Process to store and export data to a file.
    """
    def __init__(self, filename=None, path=None, timeout=0.5):
        """
        Sets up the file to export the data as CSV.
        If filename is not specified, a default name based on time will be used.
        :param filename: Name of the file where data will be exported.
        :type filename: str.
        :param path: Path where data file will be saved.
        :type path: str.
        :param timeout: Time to wait after emptying the internal buffer before next write.
        :type timeout: float.
        """
        multiprocessing.Process.__init__(self)
        self._exit = multiprocessing.Event()
        self._store_queue = multiprocessing.Queue()
        self._csv = None
        self._file = None
        self._timeout = timeout

        if filename is None:
            filename = strftime(Constants.csv_default_filename, gmtime())
        self._file = self._create_file(filename, path=path)
        Logger.i(TAG3, "Process ready")

    def add(self, time, values):
        """
        Adds a new row to fhe exported data file.
        :param time: Timestamp for the row.
        :type time: float.
        :param values: Values to add in the row.
        :type values: float list.
        :return:
        """
        array = [time]
        for value in values:
            array.append(value)
        self._store_queue.put(array)

    def run(self):
        """
        Process will monitor the internal buffer to write data to the export file,
        and the process will loop again after timeout if more data is available.
        :return:
        """
        Logger.i(TAG3, "Process starting...")
        self._csv = csv.writer(self._file, delimiter=Constants.csv_delimiter, quoting=csv.QUOTE_MINIMAL)
        while not self._exit.is_set():
            self._consume_queue()
            sleep(self._timeout)
        # last check on the queue to completely remove data.
        self._consume_queue()
        Logger.i(TAG3, "Process finished")
        self._file.close()

    def _consume_queue(self):
        """
        Consumer method for the queues/process.
        Used in run method to recall after a stop is requested, to ensure queue is emptied.
        :return:
        """
        if not self._store_queue.empty():
            while not self._store_queue.empty():
                data = self._store_queue.get(timeout=self._timeout / 10)
                if data is not None:
                    self._csv.writerow(data)

    def stop(self):
        """
        Signals the process to stop storing data.
        :return:
        """
        Logger.i(TAG3, "Process finishing...")
        self._exit.set()

    @staticmethod
    def _create_file(filename, path=None, extension=Constants.csv_extension):
        """
        Creates the file to export the data.
        :param filename: Name of the file where data will be exported.
        :type filename: str.
        :param path: Path where data file will be saved.
        :type path: str.
        :param extension: Extension to give to the export file.
        :type extension: str.
        :return: Reference to the export file.
        """
        FileManager.create_dir(path)
        full_path = FileManager.create_file(filename, extension=extension, path=path)
        if not FileManager.file_exists(full_path):
            Logger.i(TAG3, "Storing in {}".format(full_path))
            return open(full_path, "a", newline='')
        return None




class FileManager:
    """
    Wrappers for file operations.
    """

    @staticmethod
    def create_dir(path=None):
        """
        Creates a directory if the specified doesn't exists.
        :param path: Directory name or full path.
        :type path: str.
        :return: True if the specified directory exists.
        :rtype: bool.
        """
        if path is not None:
            if not os.path.isdir(path):
                os.makedirs(path)
        return os.path.isdir(path)

    @staticmethod
    def create_file(filename, extension="txt", path=None):
        """
        Creates a file full path based on parameters.
        :param filename: Name for the file.
        :type filename: str.
        :param extension: Extension for the file.
        :type extension: str.
        :param path: Path for the file, if needed.
        :type path: str.
        :return: Full path for the specified file.
        :rtype: str.
        """
        if path is None:
            full_path = str("{}.{}".format(filename, extension))
        else:
            full_path = str("{}/{}.{}".format(path, filename, extension))
        return full_path

    @staticmethod
    def file_exists(filename):
        """
        Checks if a file exists.
        :param filename: Name of the file, including path.
        :type filename: str.
        :return: True if the file exists.
        :rtype: bool.
        """
        if filename is not None:
            return os.path.isfile(filename)

class Logger:
    """
    Wrapper for logging package.
    """
    def __init__(self, level, enable_console=False):
        """
        Creates file logging (as csv) and to console, if requested.
        :param level: Level to show in Logger.
        :type level: int.
        :param enable_console: Enabled logging to console.
        :type enable_console: bool,
        """
        log_format_file = logging.Formatter('%(asctime)s,%(levelname)s,%(message)s')
        log_format_console = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
        self.logger = logging.getLogger()
        self.logger.setLevel(level.value)

        FileManager.create_dir(Constants.app_export_path)
        file_handler = logging.handlers.RotatingFileHandler("{}/{}"
                                                            .format(Constants.app_export_path, Constants.log_filename),
                                                            maxBytes=Constants.log_max_bytes,
                                                            backupCount=0)
        file_handler.setFormatter(log_format_file)
        self.logger.addHandler(file_handler)

        if enable_console:
            console_handler = logging.StreamHandler(sys.stdout)
            console_handler.setFormatter(log_format_console)
            self.logger.addHandler(console_handler)

        self._show_user_info()

    @staticmethod
    def close():
        """
        Closes the enabled loggers.
        :return:
        """
        logging.shutdown()

    @staticmethod
    def d(tag, msg):
        """
        Logs at debug level.
        :param tag: TAG to identify the Logger.
        :type tag: str.
        :param msg: Message to Logger.
        :type msg: str.
        :return:
        """
        logging.debug("[{}] {}".format(str(tag), str(msg)))

    @staticmethod
    def i(tag, msg):
        """
        Logs at info level.
        :param tag: TAG to identify the Logger.
        :type tag: str.
        :param msg: Message to Logger.
        :type msg: str.
        :return:
        """
        logging.info("[{}] {}".format(str(tag), str(msg)))

    @staticmethod
    def w(tag, msg):
        """
        Logs at warning level.
        :param tag: TAG to identify the Logger.
        :type tag: str.
        :param msg: Message to Logger.
        :type msg: str.
        :return:
        """
        logging.warning("[{}] {}".format(str(tag), str(msg)))

    @staticmethod
    def e(tag, msg):
        """
        Logs at error level.
        :param tag: TAG to identify the Logger.
        :type tag: str.
        :param msg: Message to Logger.
        :type msg: str.
        :return:
        """
        logging.error("[{}] {}".format(str(tag), str(msg)))

    @staticmethod
    def _show_user_info():
        """
        Logs at info level architecture related information.
        :return:
        """
        tag = "User"
        Logger.i(tag, "Platform: {}".format(Architecture.get_os_name()))
        Logger.i(tag, "Path: {}".format(Architecture.get_path()))
        Logger.i(tag, "Python: {}".format(Architecture.get_python_version()))


class LoggerLevel(Enum):
    """
    Enum for the Logger levels (wrappers for logging package levels).
    """
    CRITICAL = logging.CRITICAL
    ERROR = logging.ERROR
    WARNING = logging.WARNING
    INFO = logging.INFO
    DEBUG = logging.DEBUG

TAG4 = "Parser"


class ParserProcess(multiprocessing.Process):
    """
    Process to parse incoming data, parse it, and then distribute it to graph and storage.
    """
    def __init__(self, data_queue, store_reference=None,
                 split=Constants.csv_delimiter,
                 consumer_timeout=Constants.parser_timeout_ms):
        """

        :param data_queue: Reference to Queue where processed data will be put.
        :type data_queue: multiprocessing Queue.
        :param store_reference: Reference to CSVProcess instance, if needed.
        :type store_reference: CSVProcess (multiprocessing.Process)
        :param split: Delimiter in incoming data.
        :type split: str.
        :param consumer_timeout: Time to wait after emptying the internal buffer before next parsing.
        :type consumer_timeout: float.
        """
        multiprocessing.Process.__init__(self)
        self._exit = multiprocessing.Event()
        self._in_queue = multiprocessing.Queue()
        self._out_queue = data_queue
        self._consumer_timeout = consumer_timeout
        self._split = split
        self._store_reference = store_reference
        Logger.d(TAG4, "Process ready")

    def add(self, txt):
        """
        Adds new raw data to internal buffer.
        :param txt: Raw data comming from acquisition process.
        :type txt: basestring.
        :return:
        """
        self._in_queue.put(txt)

    def run(self):
        """
        Process will monitor the internal buffer to parse raw data and distribute to graph and storage, if needed.
        The process will loop again after timeout if more data is available.
        :return:
        """
        Logger.d(TAG4, "Process starting...")
        while not self._exit.is_set():
            self._consume_queue()
            sleep(self._consumer_timeout)
        # last check on the queue to completely remove data.
        self._consume_queue()
        Logger.d(TAG4, "Process finished")

    def stop(self):
        """
        Signals the process to stop parsing data.
        :return:
        """
        Logger.d(TAG4, "Process finishing...")
        self._exit.set()

    def _consume_queue(self):
        """
        Consumer method for the queues/process.
        Used in run method to recall after a stop is requested, to ensure queue is emptied.
        :return:
        """
        while not self._in_queue.empty():
            queue = self._in_queue.get(timeout=self._consumer_timeout)
            self._parse_csv(queue[0], queue[1])

    def _parse_csv(self, time, line):
        """
        Parses incoming data and distributes to external processes.
        :param time: Timestamp.
        :type time: float.
        :param line: Raw data coming from acquisition process.
        :type line: basestring.
        :return:
        """
        if len(line) > 0:
            try:
                if type(line) == bytes:
                    values = line.decode("UTF-8").split(self._split)
                elif type(line) == str:
                    values = line.split(self._split)
                else:
                    raise TypeError
                values = [float(v) for v in values]
                Logger.d(TAG4, values)
                self._out_queue.put((time, values))
                if self._store_reference is not None:
                    self._store_reference.add(time, values)
            except ValueError:
                Logger.w(TAG4, "Can't convert to float. Raw: {}".format(line.strip()))
            except AttributeError:
                Logger.w(TAG4, "Attribute error on type ({}). Raw: {}".format(type(line), line.strip()))

class PopUp:
    @staticmethod
    def question_yes_no(parent, title, message):
        """
        Shows a Pop up question dialog with yes and no buttons.
        :param parent: Parent window for the diaLogger.
        :param title: Title of the diaLogger.
        :type title: str.
        :param message: Message to be shown in the content of the diaLogger.
        :type message: str.
        :return: True if the Yes button was pressed in the diaLogger.
        :rtype: bool.
        """
        ans = QtGui.QMessageBox.question(parent,
                                         title,
                                         message,
                                         QtGui.QMessageBox.Yes,
                                         QtGui.QMessageBox.No)
        if ans == QtGui.QMessageBox.Yes:
            return True
        else:
            return False

    @staticmethod
    def warning(parent, title, message):
        """
        Shows a Pop up warning dialog with a Ok buttons.
        :param parent: Parent window for the diaLogger.
        :param title: Title of the diaLogger.
        :type title: str.
        :param message: Message to be shown in the content of the diaLogger.
        :type message: str.
        :return:
        """
        QtGui.QMessageBox.warning(parent, title, message, QtGui.QMessageBox.Ok)

class RingBuffer(object):
    def __init__(self, size_max, default_value=0.0, dtype=float):
        """
        initialization
        """
        self.size_max = size_max

        self._data = np.empty(size_max, dtype=dtype)
        self._data.fill(default_value)

        self.size = 0

    def append(self, value):
        """
        append an element
        :param value:
        """
        self._data = np.roll(self._data, 1)
        self._data[0] = value

        self.size += 1

        if self.size == self.size_max:
            self.__class__ = RingBufferFull

    def get_all(self):
        """
        return a list of elements from the oldest to the newest
        """
        return self._data

    def get_last(self):
        return self._data[0]

    def get_partial(self):
        return self.get_all()[0:self.size]

    def __getitem__(self, key):
        """
        get element
        """
        return self._data[key]

    def __repr__(self):
        """
        return string representation
        """
        s = self._data.__repr__()
        s = s + '\t' + str(self.size)
        s = s + '\t' + self.get_all()[::-1].__repr__()
        s = s + '\t' + self.get_partial()[::-1].__repr__()
        return s


class RingBufferFull(RingBuffer):
    def append(self, value):
        """
        append an element when buffer is full
        :param value:
        """
        self._data = np.roll(self._data, 1)
        self._data[0] = value

TAG5 = "Serial"


class SerialProcess(multiprocessing.Process):
    """
    Wrapper for serial package into a multiprocessing instance.
    """
    def __init__(self, parser_process):
        """
        Initialises values for process.
        :param parser_process: Reference to a ParserProcess instance.
        :type parser_process: ParserProcess.
        """
        multiprocessing.Process.__init__(self)
        self._exit = multiprocessing.Event()
        self._parser = parser_process
        self._serial = serial.Serial()
        Logger.i(TAG5, "Process ready")

    def open(self, port, speed=Constants.serial_default_speed, timeout=Constants.serial_timeout_ms):
        """
        Opens a specified serial port.
        :param port: Serial port name.
        :type port: str.
        :param speed: Baud rate, in bps, to connect to port.
        :type speed: int.
        :param timeout: Sets the general connection timeout.
        :type timeout: float.
        :return: True if the port is available.
        :rtype: bool.
        """
        self._serial.port = port
        self._serial.baudrate = int(speed)
        self._serial.stopbits = serial.STOPBITS_ONE
        self._serial.bytesize = serial.EIGHTBITS
        self._serial.timeout = timeout
        return self._is_port_available(self._serial.port)

    def run(self):
        """
        Reads the serial port expecting CSV until a stop call is made.
        The expected format is comma (",") separated values, and a new line (CRLF or LF) as a new row.
        While running, it will parse CSV data convert each value to float and added to a queue.
        If incoming data from serial port can't be converted to float, that data will be discarded.
        :return:
        """
        Logger.i(TAG5, "Process starting...")
        if self._is_port_available(self._serial.port):
            if not self._serial.isOpen():
                self._serial.open()
                Logger.i(TAG5, "Port opened")
                timestamp = time()
                while not self._exit.is_set():
                    self._parser.add([time() - timestamp, self._serial.readline()])
                Logger.i(TAG5, "Process finished")
                self._serial.close()
            else:
                Logger.w(TAG5, "Port is not opened")
        else:
            Logger.w(TAG5, "Port is not available")

    def stop(self):
        """
        Signals the process to stop acquiring data.
        :return:
        """
        Logger.i(TAG5, "Process finishing...")
        self._exit.set()

    @staticmethod
    def get_ports():
        """
        Gets a list of the available serial ports.
        :return: List of available serial ports.
        :rtype: str list.
        """
        if Architecture.get_os() is OSType.macosx:
            import glob
            return glob.glob("/dev/tty.*")
        else:
            found_ports = []
            for port in list(list_ports.comports()):
                Logger.d(TAG5, "found device {}".format(port))
                found_ports.append(port.device)
            return found_ports

    @staticmethod
    def get_speeds():
        """
        Gets a list of the common serial baud rates, in bps.
        :return: List of the common baud rates, in bps.
        :rtype: str list.
        """
        return [str(v) for v in [1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200]]

    def _is_port_available(self, port):
        """
        Checks is the port is currently connected to the host.
        :param port: Port name to be verified.
        :return: True if the port is connected to the host.
        :rtype: bool.
        """
        for p in self.get_ports():
            if p == port:
                return True
        return False

TAG6 = "Simulator"


class SimulatorProcess(multiprocessing.Process):
    """
    Simulates signals and converts them as raw data to feed the processes.
    """
    def __init__(self, parser_process):
        """
        Initialises values for process.
        :param parser_process: Reference to a ParserProcess instance.
        :type parser_process: ParserProcess.
        """
        multiprocessing.Process.__init__(self)
        self._exit = multiprocessing.Event()
        self._period = None
        self._parser = parser_process
        Logger.i(TAG6, "Process Ready")

    def open(self, port=None, speed=Constants.simulator_default_speed, timeout=0.5):
        """
        Opens a specified serial port.
        :param port: Not used.
        :type port: str.
        :param speed: Period of the generated signal.
        :type speed: float.
        :param timeout: Not used.
        :type timeout: float.
        :return: True if the port is available.
        :rtype: bool.
        """
        self._period = float(speed)
        Logger.i(TAG6, "Using sample rate at {}".format(self._period))
        return True

    def run(self):
        """
        Simulates raw data incoming as CSV.
        :return:
        """
        Logger.i(TAG6, "Process starting...")
        timestamp = time()
        coef = 2 * np.pi
        while not self._exit.is_set():
            stamp = time() - timestamp
            self._parser.add([stamp, str(("{},{}\r\n".format(np.sin(coef * stamp), np.cos(coef * stamp))))
                             .encode(Constants.app_encoding)])
            sleep(self._period)
        Logger.i(TAG6, "Process finished")
        

    def stop(self):
        """
        Signals the process to stop acquiring data.
        :return:
        """
        Logger.i(TAG6, "Process finishing...")
        self._exit.set()

    @staticmethod
    def get_ports():
        """
        Gets a list of the available ports.
        :return: List of available ports.
        :rtype: str list.
        """
        return ["Sine Simulator"]

    @staticmethod
    def get_speeds():
        """
        Gets a list of the speeds.
        :return: List of the speeds.
        :rtype: str list.
        """
        return [str(v) for v in [0.002, 0.004, 0.005, 0.010, 0.020, 0.050, 0.100, 0.250]]

TAG7 = "Socket"


class SocketProcess(multiprocessing.Process):
    """
    Socket client
    """
    def __init__(self, parser_process):
        """
        Initialises values for process.
        :param parser_process: Reference to a ParserProcess instance.
        :type parser_process: ParserProcess
        """
        multiprocessing.Process.__init__(self)
        self._exit = multiprocessing.Event()
        self._parser = parser_process
        self._socket_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        Logger.i(TAG7, "Process Ready")

    def open(self, port='', speed=5555, timeout=0.01):
        """
        Opens a socket connection to specified host and port
        :param port: Host address to connect to.
        :type port: str.
        :param speed: Port number to connect to.
        :type speed: int.
        :param timeout: Sets timeout for socket interactions.
        :type timeout: float.
        :return: True if the connection was open.
        :rtype: bool.
        """
        try:
            #self._socket_client.timeout = timeout
            speed = int(speed)
            self._socket_client.connect((port, speed))
            Logger.i(TAG7, "Socket open {}:{}".format(port, speed))
            return True
        except socket.timeout:
            Logger.w(TAG7, "Connection timeout")
        return False

    def run(self):
        """
        Reads the socket until a stop call is made.
        :return:
        """
        Logger.i(TAG7, "Process starting...")
        timestamp = time()

        while not self._exit.is_set():
            stamp = time() - timestamp
            try:
                data = self._socket_client.recv(Constants.SocketClient.buffer_recv_size).decode()
                if len(data) > 0:
                    self._parser.add([stamp, data])
            except socket.timeout:
                Logger.w(TAG7, "read timeout")
        Logger.i(TAG7, "Process finished")

    def stop(self):
        """
        Signals the process to stop acquiring data.
        :return:
        """
        Logger.i(TAG7, "Process finishing...")
        self._socket_client.close()
        self._exit.set()

    @staticmethod
    def get_default_host():
        """
        Returns a list of local host names, localhost, host name and local ip address, if available.
        :return: str list.
        """
        values = socket.gethostbyaddr(socket.gethostname())
        hostname = values[0]
        hostip = values[2][0]

        if hostip is not None:
            return [Constants.SocketClient.host_default, hostname, hostip]
        else:
            return [Constants.SocketClient.host_default, hostname]

    @staticmethod
    def get_default_port():
        """
        Returns a list of commonly used socket ports.
        :return: str list.
        """
        return [str(v) for v in Constants.SocketClient.port_default]
TAG8 = "Worker"


class Worker:
    """
    Concentrates all workers (processes) to run the application.
    """
    def __init__(self,
                 port=None,
                 speed=Constants.serial_default_speed,
                 samples=Constants.argument_default_samples,
                 source=SourceType.serial,
                 export_enabled=False,
                 export_path=Constants.app_export_path):
        """
        Creates and orchestrates all processes involved in data acquisition, processing and storing.
        :param port: Port to open on start.
        :type port: str.
        :param speed: Speed for the specified port (depending on source).
        :type speed: float.
        :param samples: Number of samples to keep in the buffers (should match with plot samples).
        :type samples: int.
        :param source: Source type where data should be obtained
        :type source: SourceType.
        :param export_enabled: If true, data will be stored or exported in a file.
        :type export_enabled: bool.
        :param export_path: If specified, defines where the data will be exported.
        :type export_path: str.
        """
        self._queue = Queue()
        self._data_buffers = None
        self._time_buffer = None
        self._lines = 0

        self._acquisition_process = None
        self._parser_process = None
        self._csv_process = None

        self._port = port
        self._speed = float(speed)
        self._samples = samples
        self._source = source
        self._export = export_enabled
        self._path = export_path

    def start(self):
        """
        Starts all processes, based on configuration given in constructor.
        :return:
        """
        self.reset_buffers(self._samples)
        if self._export:
            self._csv_process = CSVProcess(path=self._path)
            self._parser_process = ParserProcess(self._queue, store_reference=self._csv_process)
        else:
            self._parser_process = ParserProcess(self._queue)

        if self._source == SourceType.serial:
            self._acquisition_process = SerialProcess(self._parser_process)
        elif self._source == SourceType.simulator:
            self._acquisition_process = SimulatorProcess(self._parser_process)
        elif self._source == SourceType.SocketClient:
            self._acquisition_process = SocketProcess(self._parser_process)
        if self._acquisition_process.open(port=self._port, speed=self._speed):
            
            # self._parser_process.start()
            '''
            TypeError: can't pickle weakref objects when running demo in Simulator mode #7
            https://github.com/ssepulveda/RTGraph/issues/7 
            issue for python 3.7 
            this error occurred because self._parser_process.start() is called before self._acquisition_process.start()
            
            '''
            if self._export:
                self._csv_process.start()
            # call first acquisition 
            self._acquisition_process.start() 
            # call after parser 
            self._parser_process.start()
            return True
        else:
            Logger.i(TAG8, "Port is not available")
            return False

    def stop(self):
        """
        Stops all running processes.
        :return:
        """
        self.consume_queue()
        for process in [self._acquisition_process, self._parser_process, self._csv_process]:
            if process is not None and process.is_alive():
                process.stop()
                process.join(Constants.process_join_timeout_ms)

    def consume_queue(self):
        """
        Empties the internal queue, updating data to consumers.
        :return:
        """
        while not self._queue.empty():
            self._store_data(self._queue.get(False))

    def _store_data(self, data):
        """
        Adds data to internal time and data buffers.
        :param data: values to add to internal buffers.
        :type data: list.
        :return:
        """
        # Add timestamp
        self._time_buffer.append(data[0])
        # Add values
        self._store_signal_values(data[1])

    def _store_signal_values(self, values):
        """
        Stores the signal values in internal buffers.
        :param values: Values to store.
        :type values: float list.
        :return:
        """
        # detect how many lines are present to plot
        size = len(values)
        if self._lines < size:
            if size > Constants.plot_max_lines:
                self._lines = Constants.plot_max_lines
            else:
                self._lines = size

        # store the data in respective buffers
        for idx in range(self._lines):
            self._data_buffers[idx].append(values[idx])

    def get_time_buffer(self):
        """
        Gets the complete buffer for time.
        :return: Time buffer.
        :rtype: float list.
        """
        return self._time_buffer.get_all()

    def get_values_buffer(self, idx=0):
        """
        Gets the complete buffer for a line data, depending on specified index.
        :param idx: Index of the line data to get.
        :type idx: int.
        :return: float list.
        """
        return self._data_buffers[idx].get_all()

    def get_last(self, idx=0):
        return self._data_buffers[idx].get_last()

    def get_lines(self):
        """
        Gets the current number of found lines in input data.
        :return: Current number of lines.
        :rtype: int.
        """
        return self._lines

    def is_running(self):
        """
        Checks if processes are running.
        :return: True if a process is running.
        :rtype: bool.
        """
        return self._acquisition_process is not None and self._acquisition_process.is_alive()

    @staticmethod
    def get_source_ports(source):
        """
        Gets the available ports for specified source.
        :param source: Source to get available ports.
        :type source: SourceType.
        :return: List of available ports.
        :rtype: str list.
        """
        if source == SourceType.serial:
            return SerialProcess.get_ports()
        elif source == SourceType.simulator:
            return SimulatorProcess.get_ports()
        elif source == SourceType.SocketClient:
            return SocketProcess.get_default_host()
        else:
            Logger.w(TAG8, "Unknown source selected")
            return None

    @staticmethod
    def get_source_speeds(source):
        """
        Gets the available speeds for specified source.
        :param source: Source to get available speeds.
        :type source: SourceType.
        :return: List of available speeds.
        :rtype: str list.
        """
        if source == SourceType.serial:
            return SerialProcess.get_speeds()
        elif source == SourceType.simulator:
            return SimulatorProcess.get_speeds()
        elif source == SourceType.SocketClient:
            return SocketProcess.get_default_port()
        else:
            Logger.w(TAG8, "Unknown source selected")
            return None

    def reset_buffers(self, samples):
        """
        Setup/clear the internal buffers.
        :param samples: Number of samples for the buffers.
        :type samples: int.
        :return:
        """
        self._data_buffers = []
        for tmp in Constants.plot_colors:
            self._data_buffers.append(RingBuffer(samples))
        self._time_buffer = RingBuffer(samples)
        while not self._queue.empty():
            self._queue.get()
        Logger.i(TAG8, "Buffers cleared")


class Ui_AffordableQCM(object):
    def setupUi(self, AffordableQCM):
        absolute_path = os.path.dirname(__file__)
        AffordableQCM.setObjectName("AffordableQCM")
        AffordableQCM.resize(1024, 571)
        self.centralwidget = QtWidgets.QWidget(AffordableQCM)
        self.centralwidget.setObjectName("centralwidget")
        self.recordButton = QtWidgets.QToolButton(self.centralwidget)
        self.recordButton.setGeometry(QtCore.QRect(0, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.recordButton.setFont(font)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/recording.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.recordButton.setIcon(icon)
        self.recordButton.setIconSize(QtCore.QSize(70, 70))
        self.recordButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.recordButton.setObjectName("recordButton")
        self.saveButton = QtWidgets.QToolButton(self.centralwidget)
        self.saveButton.setGeometry(QtCore.QRect(93, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.saveButton.setFont(font)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/save.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.saveButton.setIcon(icon1)
        self.saveButton.setIconSize(QtCore.QSize(70, 70))
        self.saveButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.saveButton.setObjectName("saveButton")
        self.connectionButton = QtWidgets.QToolButton(self.centralwidget)
        self.connectionButton.setGeometry(QtCore.QRect(372, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.connectionButton.setFont(font)
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/usb-connection.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.connectionButton.setIcon(icon2)
        self.connectionButton.setIconSize(QtCore.QSize(70, 70))
        self.connectionButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.connectionButton.setObjectName("connectionButton")
        self.plotsButton = QtWidgets.QToolButton(self.centralwidget)
        self.plotsButton.setGeometry(QtCore.QRect(279, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.plotsButton.setFont(font)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/plot.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.plotsButton.setIcon(icon3)
        self.plotsButton.setIconSize(QtCore.QSize(70, 70))
        self.plotsButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.plotsButton.setObjectName("plotsButton")
        self.tareButton = QtWidgets.QToolButton(self.centralwidget)
        self.tareButton.setGeometry(QtCore.QRect(186, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.tareButton.setFont(font)
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/balance.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tareButton.setIcon(icon4)
        self.tareButton.setIconSize(QtCore.QSize(70, 70))
        self.tareButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.tareButton.setObjectName("tareButton")
        self.infoButton = QtWidgets.QToolButton(self.centralwidget)
        self.infoButton.setGeometry(QtCore.QRect(744, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.infoButton.setFont(font)
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/information.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.infoButton.setIcon(icon5)
        self.infoButton.setIconSize(QtCore.QSize(70, 70))
        self.infoButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.infoButton.setObjectName("infoButton")
        self.helpButton = QtWidgets.QToolButton(self.centralwidget)
        self.helpButton.setGeometry(QtCore.QRect(651, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.helpButton.setFont(font)
        icon6 = QtGui.QIcon()
        icon6.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/help.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.helpButton.setIcon(icon6)
        self.helpButton.setIconSize(QtCore.QSize(70, 70))
        self.helpButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.helpButton.setObjectName("helpButton")
        self.confirmButton = QtWidgets.QToolButton(self.centralwidget)
        self.confirmButton.setGeometry(QtCore.QRect(837, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.confirmButton.setFont(font)
        icon7 = QtGui.QIcon()
        icon7.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/manual.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.confirmButton.setIcon(icon7)
        self.confirmButton.setIconSize(QtCore.QSize(70, 70))
        self.confirmButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.confirmButton.setObjectName("confirmButton")
        self.resetButton = QtWidgets.QToolButton(self.centralwidget)
        self.resetButton.setGeometry(QtCore.QRect(930, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.resetButton.setFont(font)
        icon8 = QtGui.QIcon()
        icon8.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/reset.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.resetButton.setIcon(icon8)
        self.resetButton.setIconSize(QtCore.QSize(70, 70))
        self.resetButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.resetButton.setObjectName("resetButton")
        self.materialsButton = QtWidgets.QToolButton(self.centralwidget)
        self.materialsButton.setGeometry(QtCore.QRect(465, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.materialsButton.setFont(font)
        icon9 = QtGui.QIcon()
        icon9.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/database.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.materialsButton.setIcon(icon9)
        self.materialsButton.setIconSize(QtCore.QSize(70, 70))
        self.materialsButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.materialsButton.setObjectName("materialsButton")
        self.settingsButton = QtWidgets.QToolButton(self.centralwidget)
        self.settingsButton.setGeometry(QtCore.QRect(558, 442, 93, 100))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.settingsButton.setFont(font)
        icon10 = QtGui.QIcon()
        icon10.addPixmap(QtGui.QPixmap(os.path.join(absolute_path, "./images/settings.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.settingsButton.setIcon(icon10)
        self.settingsButton.setIconSize(QtCore.QSize(70, 70))
        self.settingsButton.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.settingsButton.setObjectName("settingsButton")
        self.materialComboBox = QtWidgets.QComboBox(self.centralwidget)
        self.materialComboBox.setGeometry(QtCore.QRect(360, 30, 221, 32))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.materialComboBox.setFont(font)
        self.materialComboBox.setObjectName("materialComboBox")
        self.materialLabel = QtWidgets.QLabel(self.centralwidget)
        self.materialLabel.setGeometry(QtCore.QRect(440, 5, 71, 21))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.materialLabel.setFont(font)
        self.materialLabel.setObjectName("materialLabel")
        self.frequencyLabel = QtWidgets.QLabel(self.centralwidget)
        self.frequencyLabel.setGeometry(QtCore.QRect(110, 5, 111, 21))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.frequencyLabel.setFont(font)
        self.frequencyLabel.setObjectName("frequencyLabel")
        self.massLabel = QtWidgets.QLabel(self.centralwidget)
        self.massLabel.setGeometry(QtCore.QRect(900, 5, 71, 21))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.massLabel.setFont(font)
        self.massLabel.setObjectName("massLabel")
        self.densityLabel = QtWidgets.QLabel(self.centralwidget)
        self.densityLabel.setGeometry(QtCore.QRect(700, 0, 81, 31))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.densityLabel.setFont(font)
        self.densityLabel.setObjectName("densityLabel")
        self.frequencyLineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.frequencyLineEdit.setGeometry(QtCore.QRect(90, 30, 151, 32))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.frequencyLineEdit.setFont(font)
        self.frequencyLineEdit.setObjectName("frequencyLineEdit")
        self.densityLineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.densityLineEdit.setGeometry(QtCore.QRect(670, 30, 120, 32))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.densityLineEdit.setFont(font)
        self.densityLineEdit.setObjectName("densityLineEdit")
        self.massLineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.massLineEdit.setGeometry(QtCore.QRect(860, 30, 121, 32))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.massLineEdit.setFont(font)
        self.massLineEdit.setObjectName("massLineEdit")
        self.stackedWidget = QtWidgets.QStackedWidget(self.centralwidget)
        self.stackedWidget.setGeometry(QtCore.QRect(20, 65, 1011, 361))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.stackedWidget.setFont(font)
        self.stackedWidget.setObjectName("stackedWidget")
        self.mainPage = QtWidgets.QWidget()
        self.mainPage.setObjectName("mainPage")
        self.thicknessLabel = QtWidgets.QLabel(self.mainPage)
        self.thicknessLabel.setGeometry(QtCore.QRect(10, 124, 431, 51))
        font = QtGui.QFont()
        font.setPointSize(36)
        font.setBold(True)
        self.thicknessLabel.setFont(font)
        self.thicknessLabel.setObjectName("thicknessLabel")
        self.frequencyBigLabel = QtWidgets.QLabel(self.mainPage)
        self.frequencyBigLabel.setGeometry(QtCore.QRect(10, 246, 431, 81))
        font = QtGui.QFont()
        font.setPointSize(36)
        font.setBold(True)
        self.frequencyBigLabel.setFont(font)
        self.frequencyBigLabel.setObjectName("frequencyBigLabel")
        self.lcdNumber = QtWidgets.QLCDNumber(self.mainPage)
        self.lcdNumber.setGeometry(QtCore.QRect(410, 110, 541, 91))
        self.lcdNumber.setDigitCount(7)
        self.lcdNumber.setObjectName("lcdNumber")
        self.lcdNumber_2 = QtWidgets.QLCDNumber(self.mainPage)
        self.lcdNumber_2.setGeometry(QtCore.QRect(410, 230, 541, 91))
        self.lcdNumber_2.setDigitCount(7)
        self.lcdNumber_2.setObjectName("lcdNumber_2")
        self.stackedWidget.addWidget(self.mainPage)
        self.savePage = QtWidgets.QWidget()
        self.savePage.setObjectName("savePage")
        self.pathLineEdit = QtWidgets.QLineEdit(self.savePage)
        self.pathLineEdit.setGeometry(QtCore.QRect(430, 120, 391, 101))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.pathLineEdit.setFont(font)
        self.pathLineEdit.setObjectName("pathLineEdit")
        self.appendRadioButton = QtWidgets.QRadioButton(self.savePage)
        self.appendRadioButton.setGeometry(QtCore.QRect(440, 240, 191, 71))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.appendRadioButton.setFont(font)
        self.appendRadioButton.setObjectName("appendRadioButton")
        self.overwriteRadioButton = QtWidgets.QRadioButton(self.savePage)
        self.overwriteRadioButton.setGeometry(QtCore.QRect(680, 240, 171, 81))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.overwriteRadioButton.setFont(font)
        self.overwriteRadioButton.setObjectName("overwriteRadioButton")
        self.frequencyCheckbox = QtWidgets.QCheckBox(self.savePage)
        self.frequencyCheckbox.setGeometry(QtCore.QRect(41, 92, 261, 51))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.frequencyCheckbox.setFont(font)
        self.frequencyCheckbox.setObjectName("frequencyCheckbox")
        self.frequencyChangeCheckbox = QtWidgets.QCheckBox(self.savePage)
        self.frequencyChangeCheckbox.setGeometry(QtCore.QRect(41, 132, 271, 51))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.frequencyChangeCheckbox.setFont(font)
        self.frequencyChangeCheckbox.setObjectName("frequencyChangeCheckbox")
        self.frequencyROCCheckbox = QtWidgets.QCheckBox(self.savePage)
        self.frequencyROCCheckbox.setGeometry(QtCore.QRect(41, 169, 291, 61))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.frequencyROCCheckbox.setFont(font)
        self.frequencyROCCheckbox.setObjectName("frequencyROCCheckbox")
        self.thicknessCheckbox = QtWidgets.QCheckBox(self.savePage)
        self.thicknessCheckbox.setGeometry(QtCore.QRect(41, 219, 231, 51))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.thicknessCheckbox.setFont(font)
        self.thicknessCheckbox.setObjectName("thicknessCheckbox")
        self.rateOfDepositionCheckbox = QtWidgets.QCheckBox(self.savePage)
        self.rateOfDepositionCheckbox.setGeometry(QtCore.QRect(41, 259, 195, 61))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.rateOfDepositionCheckbox.setFont(font)
        self.rateOfDepositionCheckbox.setObjectName("rateOfDepositionCheckbox")
        self.saveQuestionLabel = QtWidgets.QLabel(self.savePage)
        self.saveQuestionLabel.setGeometry(QtCore.QRect(41, 50, 307, 28))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.saveQuestionLabel.setFont(font)
        self.saveQuestionLabel.setObjectName("saveQuestionLabel")
        self.saveQuestionLabel_2 = QtWidgets.QLabel(self.savePage)
        self.saveQuestionLabel_2.setGeometry(QtCore.QRect(410, 40, 421, 49))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.saveQuestionLabel_2.setFont(font)
        self.saveQuestionLabel_2.setObjectName("saveQuestionLabel_2")
        self.stackedWidget.addWidget(self.savePage)
        self.materialsPage = QtWidgets.QWidget()
        self.materialsPage.setObjectName("materialsPage")
        self.materialsListWidget = QtWidgets.QListWidget(self.materialsPage)
        self.materialsListWidget.setGeometry(QtCore.QRect(60, 20, 256, 311))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.materialsListWidget.setFont(font)
        self.materialsListWidget.setObjectName("materialsListWidget")
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.materialsListWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.materialsListWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.materialsListWidget.addItem(item)
        self.addButton = QtWidgets.QPushButton(self.materialsPage)
        self.addButton.setGeometry(QtCore.QRect(410, 20, 151, 61))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.addButton.setFont(font)
        self.addButton.setObjectName("addButton")
        self.editButton = QtWidgets.QPushButton(self.materialsPage)
        self.editButton.setGeometry(QtCore.QRect(410, 130, 151, 61))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.editButton.setFont(font)
        self.editButton.setObjectName("editButton")
        self.deleteButton = QtWidgets.QPushButton(self.materialsPage)
        self.deleteButton.setGeometry(QtCore.QRect(410, 250, 151, 71))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.deleteButton.setFont(font)
        self.deleteButton.setObjectName("deleteButton")
        self.materialEditLineEdit = QtWidgets.QLineEdit(self.materialsPage)
        self.materialEditLineEdit.setGeometry(QtCore.QRect(690, 60, 281, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.materialEditLineEdit.setFont(font)
        self.materialEditLineEdit.setObjectName("materialEditLineEdit")
        self.densityEditLineEdit = QtWidgets.QLineEdit(self.materialsPage)
        self.densityEditLineEdit.setGeometry(QtCore.QRect(690, 260, 291, 41))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.densityEditLineEdit.setFont(font)
        self.densityEditLineEdit.setObjectName("densityEditLineEdit")
        self.materialEditLabel = QtWidgets.QLabel(self.materialsPage)
        self.materialEditLabel.setGeometry(QtCore.QRect(690, 20, 271, 31))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.materialEditLabel.setFont(font)
        self.materialEditLabel.setObjectName("materialEditLabel")
        self.densityEditLabel = QtWidgets.QLabel(self.materialsPage)
        self.densityEditLabel.setGeometry(QtCore.QRect(690, 220, 111, 31))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.densityEditLabel.setFont(font)
        self.densityEditLabel.setObjectName("densityEditLabel")
        self.stackedWidget.addWidget(self.materialsPage)
        self.plotPage = QtWidgets.QWidget()
        self.plotPage.setObjectName("plotPage")
        self.tabWidget = QtWidgets.QTabWidget(self.plotPage)
        self.tabWidget.setGeometry(QtCore.QRect(0, 0, 1001, 361))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.tabWidget.setFont(font)
        self.tabWidget.setObjectName("tabWidget")
        self.thicknessTab = QtWidgets.QWidget()
        self.thicknessTab.setObjectName("thicknessTab")
        self.plt_4_thickness = GraphicsLayoutWidget(self.thicknessTab)
        self.plt_4_thickness.setGeometry(QtCore.QRect(0, 0, 1000, 321))
        self.plt_4_thickness.setAutoFillBackground(False)
        self.plt_4_thickness.setStyleSheet("border: 0px;")
        self.plt_4_thickness.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.plt_4_thickness.setFrameShadow(QtWidgets.QFrame.Plain)
        self.plt_4_thickness.setLineWidth(0)
        self.plt_4_thickness.setObjectName("plt_4_thickness")
        self.tabWidget.addTab(self.thicknessTab, "")
        self.freqTab = QtWidgets.QWidget()
        self.freqTab.setObjectName("freqTab")
        self.plt6_Freq = GraphicsLayoutWidget(self.freqTab)
        self.plt6_Freq.setGeometry(QtCore.QRect(0, 0, 1000, 321))
        self.plt6_Freq.setAutoFillBackground(False)
        self.plt6_Freq.setStyleSheet("border: 0px;")
        self.plt6_Freq.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.plt6_Freq.setFrameShadow(QtWidgets.QFrame.Plain)
        self.plt6_Freq.setLineWidth(0)
        self.plt6_Freq.setObjectName("plt6_Freq")
        self.tabWidget.addTab(self.freqTab, "")
        self.freqChangeTab = QtWidgets.QWidget()
        self.freqChangeTab.setObjectName("freqChangeTab")
        self.plt_2_changeFreq = GraphicsLayoutWidget(self.freqChangeTab)
        self.plt_2_changeFreq.setGeometry(QtCore.QRect(0, 0, 1000, 321))
        self.plt_2_changeFreq.setAutoFillBackground(False)
        self.plt_2_changeFreq.setStyleSheet("border: 0px;")
        self.plt_2_changeFreq.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.plt_2_changeFreq.setFrameShadow(QtWidgets.QFrame.Plain)
        self.plt_2_changeFreq.setLineWidth(0)
        self.plt_2_changeFreq.setObjectName("plt_2_changeFreq")
        self.tabWidget.addTab(self.freqChangeTab, "")
        self.stackedWidget.addWidget(self.plotPage)
        self.connectPage = QtWidgets.QWidget()
        self.connectPage.setObjectName("connectPage")
        self.RTGraphWidget = QtWidgets.QWidget(self.connectPage)
        self.RTGraphWidget.setGeometry(QtCore.QRect(0, 170, 781, 191))
        self.RTGraphWidget.setObjectName("RTGraphWidget")
        self.Layout_controls = QtWidgets.QGridLayout(self.RTGraphWidget)
        self.Layout_controls.setContentsMargins(0, 0, 0, 0)
        self.Layout_controls.setObjectName("Layout_controls")
        self.pButton_Stop = QtWidgets.QPushButton(self.RTGraphWidget)
        self.pButton_Stop.setObjectName("pButton_Stop")
        self.Layout_controls.addWidget(self.pButton_Stop, 1, 3, 1, 1)
        self.cBox_Port = QtWidgets.QComboBox(self.RTGraphWidget)
        self.cBox_Port.setEditable(True)
        self.cBox_Port.setObjectName("cBox_Port")
        self.Layout_controls.addWidget(self.cBox_Port, 0, 1, 1, 1)
        self.cBox_Source = QtWidgets.QComboBox(self.RTGraphWidget)
        self.cBox_Source.setObjectName("cBox_Source")
        self.Layout_controls.addWidget(self.cBox_Source, 0, 0, 1, 1)
        self.pButton_Start = QtWidgets.QPushButton(self.RTGraphWidget)
        self.pButton_Start.setMinimumSize(QtCore.QSize(0, 0))
        self.pButton_Start.setObjectName("pButton_Start")
        self.Layout_controls.addWidget(self.pButton_Start, 0, 3, 1, 1)
        self.cBox_Speed = QtWidgets.QComboBox(self.RTGraphWidget)
        self.cBox_Speed.setEditable(True)
        self.cBox_Speed.setObjectName("cBox_Speed")
        self.Layout_controls.addWidget(self.cBox_Speed, 1, 1, 1, 1)
        self.sBox_Samples = QtWidgets.QSpinBox(self.RTGraphWidget)
        self.sBox_Samples.setMinimum(1)
        self.sBox_Samples.setMaximum(100000)
        self.sBox_Samples.setProperty("value", 500)
        self.sBox_Samples.setObjectName("sBox_Samples")
        self.Layout_controls.addWidget(self.sBox_Samples, 0, 2, 1, 1)
        self.plt = GraphicsLayoutWidget(self.connectPage)
        self.plt.setGeometry(QtCore.QRect(0, 10, 1000, 200))
        self.plt.setAutoFillBackground(False)
        self.plt.setStyleSheet("border: 0px;")
        self.plt.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.plt.setFrameShadow(QtWidgets.QFrame.Plain)
        self.plt.setLineWidth(0)
        self.plt.setObjectName("plt")
        self.chBox_export = QtWidgets.QCheckBox(self.connectPage)
        self.chBox_export.setEnabled(True)
        self.chBox_export.setGeometry(QtCore.QRect(430, 110, 186, 28))
        self.chBox_export.setObjectName("chBox_export")
        self.chBox_export.raise_()
        self.RTGraphWidget.raise_()
        self.plt.raise_()
        self.stackedWidget.addWidget(self.connectPage)
        self.settingsPage = QtWidgets.QWidget()
        self.settingsPage.setObjectName("settingsPage")
        self.densityUnitLabel = QtWidgets.QLabel(self.settingsPage)
        self.densityUnitLabel.setGeometry(QtCore.QRect(42, 160, 241, 28))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.densityUnitLabel.setFont(font)
        self.densityUnitLabel.setObjectName("densityUnitLabel")
        self.densityUnitComboBox = QtWidgets.QComboBox(self.settingsPage)
        self.densityUnitComboBox.setGeometry(QtCore.QRect(336, 100, 191, 36))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.densityUnitComboBox.setFont(font)
        self.densityUnitComboBox.setObjectName("densityUnitComboBox")
        self.massUnitLabel = QtWidgets.QLabel(self.settingsPage)
        self.massUnitLabel.setGeometry(QtCore.QRect(42, 110, 251, 28))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.massUnitLabel.setFont(font)
        self.massUnitLabel.setObjectName("massUnitLabel")
        self.massUnitComboBox = QtWidgets.QComboBox(self.settingsPage)
        self.massUnitComboBox.setGeometry(QtCore.QRect(336, 160, 191, 36))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.massUnitComboBox.setFont(font)
        self.massUnitComboBox.setObjectName("massUnitComboBox")
        self.thicknessUnitComboBox = QtWidgets.QComboBox(self.settingsPage)
        self.thicknessUnitComboBox.setGeometry(QtCore.QRect(336, 220, 191, 36))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.thicknessUnitComboBox.setFont(font)
        self.thicknessUnitComboBox.setObjectName("thicknessUnitComboBox")
        self.thicknessUnitLabel = QtWidgets.QLabel(self.settingsPage)
        self.thicknessUnitLabel.setGeometry(QtCore.QRect(42, 220, 251, 28))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.thicknessUnitLabel.setFont(font)
        self.thicknessUnitLabel.setObjectName("thicknessUnitLabel")
        self.rateOfDepositionUnitLabel = QtWidgets.QLabel(self.settingsPage)
        self.rateOfDepositionUnitLabel.setGeometry(QtCore.QRect(42, 280, 261, 28))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.rateOfDepositionUnitLabel.setFont(font)
        self.rateOfDepositionUnitLabel.setObjectName("rateOfDepositionUnitLabel")
        self.rateOfDepositionComboBox = QtWidgets.QComboBox(self.settingsPage)
        self.rateOfDepositionComboBox.setGeometry(QtCore.QRect(336, 280, 191, 36))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.rateOfDepositionComboBox.setFont(font)
        self.rateOfDepositionComboBox.setObjectName("rateOfDepositionComboBox")
        self.toolingFactorSpinBox = QtWidgets.QDoubleSpinBox(self.settingsPage)
        self.toolingFactorSpinBox.setGeometry(QtCore.QRect(830, 160, 121, 91))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.toolingFactorSpinBox.setFont(font)
        self.toolingFactorSpinBox.setMaximum(100.0)
        self.toolingFactorSpinBox.setSingleStep(0.1)
        self.toolingFactorSpinBox.setProperty("value", 100.0)
        self.toolingFactorSpinBox.setObjectName("toolingFactorSpinBox")
        self.toolingFactorLabel = QtWidgets.QLabel(self.settingsPage)
        self.toolingFactorLabel.setGeometry(QtCore.QRect(630, 160, 121, 71))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.toolingFactorLabel.setFont(font)
        self.toolingFactorLabel.setObjectName("toolingFactorLabel")
        self.aliasingLabel = QtWidgets.QLabel(self.settingsPage)
        self.aliasingLabel.setGeometry(QtCore.QRect(630, 250, 251, 71))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.aliasingLabel.setFont(font)
        self.aliasingLabel.setObjectName("aliasingLabel")
        self.aliasingNOButton = QtWidgets.QRadioButton(self.settingsPage)
        self.aliasingNOButton.setGeometry(QtCore.QRect(900, 251, 91, 51))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.aliasingNOButton.setFont(font)
        self.aliasingNOButton.setObjectName("aliasingNOButton")
        self.aliasingYESButton = QtWidgets.QRadioButton(self.settingsPage)
        self.aliasingYESButton.setGeometry(QtCore.QRect(900, 300, 91, 51))
        font = QtGui.QFont()
        font.setPointSize(16)
        self.aliasingYESButton.setFont(font)
        self.aliasingYESButton.setObjectName("aliasingYESButton")
        self.stackedWidget.addWidget(self.settingsPage)
        self.helpPage = QtWidgets.QWidget()
        self.helpPage.setObjectName("helpPage")
        self.stackedWidget.addWidget(self.helpPage)
        self.infoPage = QtWidgets.QWidget()
        self.infoPage.setObjectName("infoPage")
        self.authorsLabel = QtWidgets.QLabel(self.infoPage)
        self.authorsLabel.setGeometry(QtCore.QRect(0, 0, 1031, 361))
        self.authorsLabel.setObjectName("authorsLabel")
        self.stackedWidget.addWidget(self.infoPage)
        AffordableQCM.setCentralWidget(self.centralwidget)

        self.retranslateUi(AffordableQCM)
        self.stackedWidget.setCurrentIndex(0)
        self.tabWidget.setCurrentIndex(1)
        QtCore.QMetaObject.connectSlotsByName(AffordableQCM)

    def retranslateUi(self, AffordableQCM):
        _translate = QtCore.QCoreApplication.translate
        AffordableQCM.setWindowTitle(_translate("AffordableQCM", "MainWindow"))
        self.recordButton.setText(_translate("AffordableQCM", "RECORD"))
        self.saveButton.setText(_translate("AffordableQCM", "SAVE"))
        self.connectionButton.setText(_translate("AffordableQCM", "CONNECT"))
        self.plotsButton.setText(_translate("AffordableQCM", "PLOTS"))
        self.tareButton.setText(_translate("AffordableQCM", "TARE"))
        self.infoButton.setText(_translate("AffordableQCM", "INFO"))
        self.helpButton.setText(_translate("AffordableQCM", "HELP"))
        self.confirmButton.setText(_translate("AffordableQCM", "CONFIRM"))
        self.resetButton.setText(_translate("AffordableQCM", "RESET"))
        self.materialsButton.setText(_translate("AffordableQCM", "MATERIALS"))
        self.settingsButton.setText(_translate("AffordableQCM", "SETTINGS"))
        self.materialLabel.setText(_translate("AffordableQCM", "Material"))
        self.frequencyLabel.setText(_translate("AffordableQCM", "Frequency"))
        self.massLabel.setText(_translate("AffordableQCM", "Mass"))
        self.densityLabel.setText(_translate("AffordableQCM", "Density"))
        self.thicknessLabel.setText(_translate("AffordableQCM", "Thickness [nm]"))
        self.frequencyBigLabel.setText(_translate("AffordableQCM", "FREQUENCY"))
        self.appendRadioButton.setText(_translate("AffordableQCM", "Append?"))
        self.overwriteRadioButton.setText(_translate("AffordableQCM", "Overwrite?"))
        self.frequencyCheckbox.setText(_translate("AffordableQCM", "Frequency"))
        self.frequencyChangeCheckbox.setText(_translate("AffordableQCM", "Frequency Change"))
        self.frequencyROCCheckbox.setText(_translate("AffordableQCM", "Frequency Rate of Change"))
        self.thicknessCheckbox.setText(_translate("AffordableQCM", "Thickness"))
        self.rateOfDepositionCheckbox.setText(_translate("AffordableQCM", "Rate of deposition"))
        self.saveQuestionLabel.setText(_translate("AffordableQCM", "Which data do you want to save?"))
        self.saveQuestionLabel_2.setText(_translate("AffordableQCM", "Path to file (e.g.) /data/20221001_gold01.csv"))
        __sortingEnabled = self.materialsListWidget.isSortingEnabled()
        self.materialsListWidget.setSortingEnabled(False)
        item = self.materialsListWidget.item(0)
        item.setText(_translate("AffordableQCM", "Gold"))
        item = self.materialsListWidget.item(1)
        item.setText(_translate("AffordableQCM", "Platinum"))
        item = self.materialsListWidget.item(2)
        item.setText(_translate("AffordableQCM", "Carbon"))
        self.materialsListWidget.setSortingEnabled(__sortingEnabled)
        self.addButton.setText(_translate("AffordableQCM", "Add"))
        self.editButton.setText(_translate("AffordableQCM", "Edit"))
        self.deleteButton.setText(_translate("AffordableQCM", "Delete"))
        self.materialEditLabel.setText(_translate("AffordableQCM", "Material name"))
        self.densityEditLabel.setText(_translate("AffordableQCM", "Density"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.thicknessTab), _translate("AffordableQCM", "Thickness"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.freqTab), _translate("AffordableQCM", "Absolute frequency"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.freqChangeTab), _translate("AffordableQCM", "Frequency change"))
        self.pButton_Stop.setText(_translate("AffordableQCM", "Stop"))
        self.pButton_Start.setText(_translate("AffordableQCM", "Start"))
        self.sBox_Samples.setSuffix(_translate("AffordableQCM", " samples"))
        self.sBox_Samples.setPrefix(_translate("AffordableQCM", "Show "))
        self.chBox_export.setText(_translate("AffordableQCM", "Export to CSV"))
        self.densityUnitLabel.setText(_translate("AffordableQCM", "Density unit"))
        self.massUnitLabel.setText(_translate("AffordableQCM", "Mass unit"))
        self.thicknessUnitLabel.setText(_translate("AffordableQCM", "Thickness unit"))
        self.rateOfDepositionUnitLabel.setText(_translate("AffordableQCM", "Rate of deposition unit"))
        self.toolingFactorLabel.setText(_translate("AffordableQCM", "<html><head/><body><p>Tooling<br/>Factor</p></body></html>"))
        self.aliasingLabel.setText(_translate("AffordableQCM", "<html><head/><body><p>Quartz frequency &gt; 8MHz?</p></body></html>"))
        self.aliasingNOButton.setText(_translate("AffordableQCM", "NO"))
        self.aliasingYESButton.setText(_translate("AffordableQCM", "YES"))
        self.authorsLabel.setText(_translate("AffordableQCM", "<html><head/><body><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">You should have received a copy of the GNU General Public License along with this program.</span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">If not, see https://www.gnu.org/licenses/ </span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License</span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">The app was created as a part of an engineering thesis: Design of the gauge for the sputtered coating thickness measurement.&quot;</span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">Copyright (C) 2022 Adrian Matusiak</span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;</span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:19px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">See the GNU General Public License for more details.</span></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">The software contains code written by Marco Mauro (same license) and code by Sebastin Seplveda (MIT License).</span></pre><pre style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'Courier New\'; background-color:#1e1e1e;\"><br/></pre><pre style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#1e1e1e;\"><span style=\" font-family:\'Consolas\',\'Courier New\',\'monospace\'; font-size:14px; color:#ce9178;\">Icons made by https://www.freepik.com Freepik from https://www.flaticon.com/</span></pre><pre style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\'Courier New\'; background-color:#1e1e1e;\"><br/></pre><p><br/></p></body></html>"))

class ControlMainWindow(QtWidgets.QMainWindow):
    def __init__(self, parent=None, port=None, bd=115200, samples=500):
        super(ControlMainWindow, self).__init__(parent)
        self.ui = Ui_AffordableQCM()
        self.ui.setupUi(self)

        self._plt = None
        self.plt_4_thickness = None

        self.plt6_Freq = None
        self._timer_plot = None
        self.plt_2_changeFreq = None
        
        self.worker = Worker()

        # configures
        self.ui.cBox_Source.addItems(Constants.app_sources)
        self._configure_plot()
        self._configure_timers()
        self._configure_signals()

        # populate combo box for serial ports
        self._source_changed()
        self.ui.cBox_Source.setCurrentIndex(SourceType.serial.value)

        self.ui.sBox_Samples.setValue(samples)

        # enable ui
        self._enable_ui(True)
        pathname = self.ui.pathLineEdit.text()
        if pathname== '':
            pathname="default.csv"
        with open(pathname, 'w', newline='') as csvfile:
            fieldnames = ['Absolute Frequency', 'Frequency change', 'Thickness[nm]', 'Timestamp']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            writer.writeheader()
            csvfile.close()



        self.ui.saveButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(1))
        self.ui.materialsButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(2))
        self.ui.plotsButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(3))
        self.ui.resetButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(0))
        self.ui.settingsButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(5))
        self.ui.connectionButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(4))
        self.ui.helpButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(6))
        self.ui.infoButton.clicked.connect(lambda : self.ui.stackedWidget.setCurrentIndex(7))
        # self.ui.tareButton.clicked(tare = lambda: self.ui.frequencyLineEdit()) 
            
        if (self.ui.stackedWidget.currentIndex() == 1):
            pass
        if (self.ui.stackedWidget.currentIndex() == 2):
            pass
        if (self.ui.stackedWidget.currentIndex() == 4):
            pass
        if (self.ui.stackedWidget.currentIndex() == 5):
            pass
    def start(self):
        """
        Starts the acquisition of the selected serial port.
        This function is connected to the clicked signal of the Start button.
        :return:
        """
        Logger.i(TAG2, "Clicked start")
        self.worker = Worker(port=self.ui.cBox_Port.currentText(),
                             speed=float(self.ui.cBox_Speed.currentText()),
                             samples=self.ui.sBox_Samples.value(),
                             source=self._get_source(),
                             export_enabled=self.ui.chBox_export.isChecked())
        if self.worker.start():
            self._timer_plot.start(Constants.plot_update_ms)
            self._enable_ui(False)
        else:
            Logger.i(TAG2, "Port is not available")
            PopUp.warning(self, Constants.app_title, "Selected port \"{}\" is not available"
                          .format(self.ui.cBox_Port.currentText()))

    def stop(self):
        """
        Stops the acquisition of the selected serial port.
        This function is connected to the clicked signal of the Stop button.
        :return:
        """
        Logger.i(TAG2, "Clicked stop")
        self._timer_plot.stop()
        self._enable_ui(True)
        self.worker.stop()

    def closeEvent(self, evnt):
        """
        Overrides the QTCloseEvent.
        This function is connected to the clicked signal of the close button of the window.
        :param evnt: QT evnt.
        :return:
        """
        if self.worker.is_running():
            Logger.i(TAG2, "Window closed without stopping capture, stopping it")
            self.stop()

    def _enable_ui(self, enabled):
        """
        Enables or disables the UI elements of the window.
        :param enabled: The value to be set at the enabled characteristic of the UI elements.
        :type enabled: bool
        :return:
        """
        self.ui.cBox_Port.setEnabled(enabled)
        self.ui.cBox_Speed.setEnabled(enabled)
        self.ui.pButton_Start.setEnabled(enabled)
        self.ui.chBox_export.setEnabled(enabled)
        self.ui.cBox_Source.setEnabled(enabled)
        self.ui.pButton_Stop.setEnabled(not enabled)

    def _configure_plot(self):
        """
        Configures specific elements of the PyQtGraph plots.
        :return:
        """
        self._yaxis = AxisItem('left', pen=None, linkView=None, parent=None, maxTickLength=-5, showValues=True, text='Frequency', units='Hz')
        self._yaxis.setFixedWidth(77)
        self._yaxis.setWidth(77)

        self._yaxis2 = AxisItem('left', pen=None, linkView=None, parent=None, maxTickLength=-5, showValues=True, text='thickness', units='nm')
        self._yaxis2.setFixedWidth(77)
        self._yaxis2.setWidth(77)

        self._yaxis3 = AxisItem('left', pen=None, linkView=None, parent=None, maxTickLength=-5, showValues=True, text='Frequency', units='Hz')
        self._yaxis3.setFixedWidth(77)
        self._yaxis3.setWidth(77)

        self._yaxis4 = AxisItem('left', pen=None, linkView=None, parent=None, maxTickLength=-5, showValues=True, text='Frequency', units='Hz')
        self._yaxis4.setFixedWidth(77)
        self._yaxis4.setWidth(77)

        self._yaxis.setLabel(show=True)
        self._yaxis.setGrid(grid=True)
        #self.ui.plt.setBackground(background=None)
        self.ui.plt.setAntialiasing(True)
        self._plt = self.ui.plt.addPlot(row=0, col=0, axisItems={'left':self._yaxis})
        self._plt.setLabel('bottom', Constants.plot_xlabel_title, Constants.plot_xlabel_unit)

        self.ui.plt_4_thickness.setAntialiasing(True)
        self._plt_4_thickness = self.ui.plt_4_thickness.addPlot(row=0, col=0, axisItems={'left':self._yaxis2})
        self._plt_4_thickness.setLabel('bottom', Constants.plot_xlabel_title, Constants.plot_xlabel_unit)


        self.ui.plt6_Freq.setAntialiasing(True)
        self._plt6_Freq = self.ui.plt6_Freq.addPlot(row=0, col=0, axisItems={'left':self._yaxis3})
        self._plt6_Freq.setLabel('bottom', Constants.plot_xlabel_title, Constants.plot_xlabel_unit)

        self.ui.plt_2_changeFreq.setAntialiasing(True)
        self._plt_2_changeFreq = self.ui.plt_2_changeFreq.addPlot(row=0, col=0, axisItems={'left':self._yaxis4})
        self._plt_2_changeFreq.setLabel('bottom', Constants.plot_xlabel_title, Constants.plot_xlabel_unit)


    def _configure_timers(self):
        """
        Configures specific elements of the QTimers.
        :return:
        """
        self._timer_plot = QtCore.QTimer(self)
        self._timer_plot.timeout.connect(self._update_plot)

    def _configure_signals(self):
        """
        Configures the connections between signals and UI elements.
        :return:
        """
        self.ui.pButton_Start.clicked.connect(self.start)
        self.ui.pButton_Stop.clicked.connect(self.stop)
        self.ui.sBox_Samples.valueChanged.connect(self._update_sample_size)
        self.ui.cBox_Source.currentIndexChanged.connect(self._source_changed)

    def _update_sample_size(self):
        """
        Updates the sample size of the plot.
        This function is connected to the valueChanged signal of the sample Spin Box.
        :return:
        """
        if self.worker is not None:
            Logger.i(TAG2, "Changing sample size")
            self.worker.reset_buffers(self.ui.sBox_Samples.value())

    def _update_plot(self):
        """
        Updates and redraws the graphics in the plot.
        This function us connected to the timeout signal of a QTimer.
        :return:
        """
        self.worker.consume_queue()
        pathname = self.ui.pathLineEdit.text()
        tracker.track_object(self.worker)
        tracker.track_class(Worker)
        if pathname== '':
            pathname="default.csv"
            
        if not (file_exists(pathname)):
            with open(pathname, 'w', newline='') as csvfile:
                fieldnames = ['Absolute Frequency', 'Frequency change', 'Thickness[nm]', 'Timestamp']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                pass
                writer.writeheader()
                csvfile.close()
        else:
            with open(pathname, 'a', newline='') as f_object:
               
                writer_object = csv.writer(f_object)
                # Pass the list as an argument into
                # the writerow()
                xx=[]
                yy=[]
                for idx in range(self.worker.get_lines()):
                    
                    xx=self.worker.get_time_buffer()
                    yy=self.worker.get_values_buffer(idx)
                    tracker.track_object(xx)
                    tracker.track_object(yy)
                    tracker.create_snapshot()
                    tracker.stats.print_summary()
                if xx[0] is not None:
                    self.ui.frequencyLineEdit.setText(str(yy[0]) + " Hz")
                    List=[yy[0],yy[0]-tare,(yy[0]-tare)/density,datetime.now()]
                    writer_object.writerow(List)
    
        #Close the file object
                f_object.close()

        # plot data
        self._plt.clear()
        for idx in range(self.worker.get_lines()):
            self._plt.plot(x=self.worker.get_time_buffer(),
                           y=self.worker.get_values_buffer(idx),
                           pen=Constants.plot_colors[idx])
        self._plt_2_changeFreq.clear()
        for idx in range(self.worker.get_lines()):
            self._plt_2_changeFreq.plot(x=self.worker.get_time_buffer(),
                           y=self.worker.get_values_buffer(idx)-tare,
                           pen=Constants.plot_colors[idx])
        self._plt6_Freq.clear()
        for idx in range(self.worker.get_lines()):
            self._plt6_Freq.plot(x=self.worker.get_time_buffer(),
                           y=self.worker.get_values_buffer(idx),
                           pen=Constants.plot_colors[idx])
        
        self.ui.plt_4_thickness.clear()
        for idx in range(self.worker.get_lines()):
            self._plt_4_thickness.plot(x=self.worker.get_time_buffer(),
                           y=(self.worker.get_values_buffer(idx)-tare)/density,
                           pen=Constants.plot_colors[idx])



    def _source_changed(self):
        """
        Updates the source and depending boxes on change.
        This function is connected to the indexValueChanged signal of the Source ComboBox.
        :return:
        """
        Logger.i(TAG2, "Scanning source {}".format(self._get_source().name))
        # clear boxes before adding new
        self.ui.cBox_Port.clear()
        self.ui.cBox_Speed.clear()

        source = self._get_source()
        ports = self.worker.get_source_ports(source)
        speeds = self.worker.get_source_speeds(source)

        if ports is not None:
            self.ui.cBox_Port.addItems(ports)
        if speeds is not None:
            self.ui.cBox_Speed.addItems(speeds)
        if self._get_source() == SourceType.serial:
            self.ui.cBox_Speed.setCurrentIndex(len(speeds) - 1)

    def _get_source(self):
        """
        Gets the current source type.
        :return: Current Source type.
        :rtype: SourceType.
        """
        return SourceType(self.ui.cBox_Source.currentIndex())

    
        


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    mySW = ControlMainWindow()
    mySW.show()
    sys.exit(app.exec_())
